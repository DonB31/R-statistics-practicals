# Chunk 4: Calcul_probabilite
data_sequoia = read.table(params$fichier_sequoia , sep = params$separateur_sequoia , header = TRUE)
names(data_sequoia)
hist(data_sequoia$taille_arbre,
main="Histogramme representant la taille des arbres Sequoia",
ylab='Frequence',
col='salmon' )
mean_taille_sequoia = mean(data_sequoia$taille_arbre)
ecart_type_sequoia = sd(data_sequoia$taille_arbre)
cat("La taille moyenne est de" , mean_taille_sequoia , " et l'écart-type est" , ecart_type_sequoia
)
histogramme_taille_arbre = function() { hist(data_sequoia$taille_arbre , main="Histogramme representant la taille des arbres Sequoia" , ylab='Frequence' , xlab='Taille des arbres' ) }
histogramme_taille_arbre()
outfile_seq = here("figure_tp2" , "histogramme_taille_arbre.jpg")
jpeg(outfile_seq)
histogramme_taille_arbre()
dev.off()
if ( file.exists(outfile_seq)) {
cat("Le fichier a bien ete genérée.
")
} # Utilisation de if pour envoyer un output qui confirme l'existence de notre fichier.
## Quel est la probabilité qu'un arbre mesure 80 m ?
proba_arbre_80m = length(which(data_sequoia$taille_arbre==80))/length(data_sequoia$taille_arbre)
cat("La probabilité qu'un arbre mesure 80m est de", proba_arbre_80m)
## Quel est la probabilité qu'un arbre mesure 100 m ?
proba_arbre_100m = length(data_sequoia$taille_arbre[data_sequoia$taille_arbre>100])/length(data_sequoia$taille_arbre)
cat("La probabilité qu'un arbre mesure 100m est de", proba_arbre_100m)
## Calcul basés sur une loi centrée réduite N(0,1)
dnorm(0,0,1) # On a ici x=0, mean=0 et sd=1 respectivement. Ici , x est une variable aleatoire, mean correspond à la mean de la population et sd c'est l'ecart type de la popualtion.
hist(rnorm(100,0,1), col='red')
# En augmentant n, on va tendre vers une figure de plus en plus symetrique centrée normale.
pnorm(0,0,1)
hist(rnorm(10000,0,1))
# On va calculer la mean et écart type des tailles des séquoia pour calculer la probabilité qu'u arbre mesure 80m.
calcul_arbre80m = round(dnorm(80,mean_taille_sequoia , ecart_type_sequoia ) , 3)
calcul_arbre80m
calcul_arbre100m = round(pnorm(100,mean_taille_sequoia, ecart_type_sequoia, lower.tail = FALSE),3)
calcul_arbre100m
# Chunk 5
cat("La probabilité qu'un arbre fasse 80m selon la loi normal est de",calcul_arbre80m)
cat("Le calcul des probabilités qu'un arbre mesure 100m ou plus est de", calcul_arbre100m,". Cette valeur est legerement differente que le calcul direct par nombre d'arbres de 100m divisé par le total.", proba_arbre_100m, "vs", calcul_arbre100m)
# Chunk 6: Loi_Binomiale
n=100
p=0.8
proba_80_graines_germent = dbinom(80,n,prob=p)
proba_au_max80_graines_germent = pbinom(80,n,prob=p)
proba_plus_de_80_graines_germent = pbinom(80,n,prob=p , lower.tail=F)
cat("La probabilité que 80 graines germent est de" ,proba_80_graines_germent)
# Chunk 7
cat("La probabilité que au maximum 80 graines germent est de",proba_au_max80_graines_germent)
cat("La probabilité que plus de 80 graines germent est de",proba_plus_de_80_graines_germent)
# Pour trouver combien de graines en mean devraient germer, on multiplie n par p (np)
mean_graines_germes = n*p
cat("D'apres notre n et p, on devrait s'attendre en mean a" , mean_graines_germes)
k = seq(0,100,1)
## Afficher figure
figure_loi_binomiale = function() { plot(dbinom(k,100,prob=0.8), xlab="k" , ylab="Prob(X=k)" , col="red", main="Loi Binomiale B(100,0.8)") }
figure_loi_binomiale()
outfile = here("figure_tp2" , "figure_loi_binomiale.jpg")
jpeg(outfile)
figure_loi_binomiale()
dev.off()
if ( file.exists(outfile)) {
cat("Le fichier a bien ete genérée. ") }
# Utilisation de if pour envoyer un output qui confirme l'existence de notre fichier.
# Chunk 8: Intervalle_de_confiance
data_tomatos = read.table(params$fichier_tomatos , sep = params$separateur_tomatos , header=T)
names(data_tomatos)
mean_tomatos = mean(data_tomatos$poids_tomate)
sd_tomatos = sd(data_tomatos$poids_tomate)
n_tomatos = length(data_tomatos$poids_tomate)
# Intervalle de confiance de la mean théorique µ de la popualtion, à partir de la mean m calculé sur un échantillon.
# Intervalle de confiance a 95%
error = qt(0.975, df=n-1)*sd_tomatos/sqrt(n_tomatos)
left = mean_tomatos - error
right = mean_tomatos + error
left;right
# Chunk 9
cat("L'intervalle de confiance a 95% sera compris entre", left , "et" , right, ". On peut estimer que la mean de la taille des tomatos de la population se trouve dans cette intervalle ave cun risque d'erreur de 5%. ")
# Chunk 10
error_99 = qt(0.995, df=n-1)*sd_tomatos/sqrt(n_tomatos)
left_99_tomatos = mean_tomatos - error_99
right_99_tomatos = mean_tomatos + error_99
left_99_tomatos;right_99_tomatos
# Chunk 11
cat("L'intervalle de confiance a 95% sera compris entre", left_99_tomatos , "et" , right_99_tomatos , ". On peut estimer que la mean de la taille des tomatos de la population se trouve dans cette intervalle ave cun risque d'erreur de 1%.")
# Chunk 12
frequence_red_apples = 0.4 # fréquence de pommes rouges dans l'échantillon
n = 125 # taille de l'échantillon
error_red_apple = qnorm(0.975)*sqrt(frequence_red_apples*(1-frequence_red_apples)/n)
left_apples = frequence_red_apples - error_red_apple
right_apples = frequence_red_apples + error_red_apple
left_apples;right_apples
cat("L'intervalle ayant 95% de chance d'obtenir la vrai proportion p de la popualtion est entre" , left_apples, "et",  right_apples)
if ( file.exists(outfile_seq)) {
cat("Le fichier a bien ete genérée.
" , outfile_seq )
} # Utilisation de if pour envoyer un output qui confirme l'existence de notre fichier.
cat("Le fichier a bien ete genérée. " , outfile) }
if ( file.exists(outfile)) {
cat("Le fichier a bien ete genérée. " , outfile) }
# Chunk 1: Chemins_fichiers
# On peut nommer les Chunk
library(here)
# creer un dossier ou stocker les figures si besoin
dir.create(here("figure_tp2") , recursive = TRUE)
# Chunk 2: Setup de notre Rmd
knitr::opts_chunk$set(echo = TRUE , warning = FALSE , message = FALSE ,
fig.width = 6, fig.height = 4 , dpi =150,
fig.path = "figure_tp2/"
)
# Ici, nous allons etablir les options pour l'affichage du code, message d'erreur et le format des images)
# Chunk 3: Regression_lineaire
genomes = read.table(params$fichier_bacteries , sep = params$separateur_bacterias , header = TRUE)
names(genomes)
with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
# L'unité de mesure est de l'ordre des milions de paires de bases.
# On peut calculer la relation entre ces 2 variables mais aussi le coefficient de Pearson.
cov_xy = with(genomes, cov(Genome_size , ORF_number))
r_xy = with(genomes, cor(Genome_size , ORF_number))
cat(sprintf("Covariance = %.0f ; r (Pearson) = %.2f\n", cov_xy, r_xy))
#On observe une valeur de covariance de 4005883 et un coefficient de correlation de Pearson de 0.96. On a une correlation positive.
ligneregression= lm(ORF_number~Genome_size, data = genomes) # Nous n'avons utilisé pas attach donc faut lui preciser sur quoi on travaille.
# Ajout de la droite de regréssion
with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
abline(ligneregression , col="red", lwd=2)
summary(ligneregression)
# Chunk 4: Calcul_probabilite
data_sequoia = read.table(params$fichier_sequoia , sep = params$separateur_sequoia , header = TRUE)
names(data_sequoia)
hist(data_sequoia$taille_arbre,
main="Histogramme representant la taille des arbres Sequoia",
ylab='Frequence',
col='salmon' )
mean_taille_sequoia = mean(data_sequoia$taille_arbre)
ecart_type_sequoia = sd(data_sequoia$taille_arbre)
cat("La taille moyenne est de" , mean_taille_sequoia , " et l'écart-type est" , ecart_type_sequoia
)
histogramme_taille_arbre = function() { hist(data_sequoia$taille_arbre , main="Histogramme representant la taille des arbres Sequoia" , ylab='Frequence' , xlab='Taille des arbres' ) }
histogramme_taille_arbre()
outfile_seq = here("figure_tp2" , "histogramme_taille_arbre.jpg")
jpeg(outfile_seq)
histogramme_taille_arbre()
dev.off()
if ( file.exists(outfile_seq)) {
cat("Le fichier a bien ete genérée.
" , outfile_seq )
} # Utilisation de if pour envoyer un output qui confirme l'existence de notre fichier.
## Quel est la probabilité qu'un arbre mesure 80 m ?
proba_arbre_80m = length(which(data_sequoia$taille_arbre==80))/length(data_sequoia$taille_arbre)
cat("La probabilité qu'un arbre mesure 80m est de", proba_arbre_80m)
## Quel est la probabilité qu'un arbre mesure 100 m ?
proba_arbre_100m = length(data_sequoia$taille_arbre[data_sequoia$taille_arbre>100])/length(data_sequoia$taille_arbre)
cat("La probabilité qu'un arbre mesure 100m est de", proba_arbre_100m)
## Calcul basés sur une loi centrée réduite N(0,1)
dnorm(0,0,1) # On a ici x=0, mean=0 et sd=1 respectivement. Ici , x est une variable aleatoire, mean correspond à la mean de la population et sd c'est l'ecart type de la popualtion.
hist(rnorm(100,0,1), col='red')
# En augmentant n, on va tendre vers une figure de plus en plus symetrique centrée normale.
pnorm(0,0,1)
hist(rnorm(10000,0,1))
# On va calculer la mean et écart type des tailles des séquoia pour calculer la probabilité qu'u arbre mesure 80m.
calcul_arbre80m = round(dnorm(80,mean_taille_sequoia , ecart_type_sequoia ) , 3)
calcul_arbre80m
calcul_arbre100m = round(pnorm(100,mean_taille_sequoia, ecart_type_sequoia, lower.tail = FALSE),3)
calcul_arbre100m
# Chunk 5
cat("La probabilité qu'un arbre fasse 80m selon la loi normal est de",calcul_arbre80m)
cat("Le calcul des probabilités qu'un arbre mesure 100m ou plus est de", calcul_arbre100m,". Cette valeur est legerement differente que le calcul direct par nombre d'arbres de 100m divisé par le total.", proba_arbre_100m, "vs", calcul_arbre100m)
# Chunk 6: Loi_Binomiale
n=100
p=0.8
proba_80_graines_germent = dbinom(80,n,prob=p)
proba_au_max80_graines_germent = pbinom(80,n,prob=p)
proba_plus_de_80_graines_germent = pbinom(80,n,prob=p , lower.tail=F)
cat("La probabilité que 80 graines germent est de" ,proba_80_graines_germent)
# Chunk 7
cat("La probabilité que au maximum 80 graines germent est de",proba_au_max80_graines_germent)
cat("La probabilité que plus de 80 graines germent est de",proba_plus_de_80_graines_germent)
# Pour trouver combien de graines en mean devraient germer, on multiplie n par p (np)
mean_graines_germes = n*p
cat("D'apres notre n et p, on devrait s'attendre en mean a" , mean_graines_germes)
k = seq(0,100,1)
## Afficher figure
figure_loi_binomiale = function() { plot(dbinom(k,100,prob=0.8), xlab="k" , ylab="Prob(X=k)" , col="red", main="Loi Binomiale B(100,0.8)") }
figure_loi_binomiale()
outfile = here("figure_tp2" , "figure_loi_binomiale.jpg")
jpeg(outfile)
figure_loi_binomiale()
dev.off()
if ( file.exists(outfile)) {
cat("Le fichier a bien ete genérée. " , outfile) }
# Utilisation de if pour envoyer un output qui confirme l'existence de notre fichier.
# Chunk 8: Intervalle_de_confiance
data_tomatos = read.table(params$fichier_tomatos , sep = params$separateur_tomatos , header=T)
names(data_tomatos)
mean_tomatos = mean(data_tomatos$poids_tomate)
sd_tomatos = sd(data_tomatos$poids_tomate)
n_tomatos = length(data_tomatos$poids_tomate)
# Intervalle de confiance de la mean théorique µ de la popualtion, à partir de la mean m calculé sur un échantillon.
# Intervalle de confiance a 95%
error = qt(0.975, df=n-1)*sd_tomatos/sqrt(n_tomatos)
left = mean_tomatos - error
right = mean_tomatos + error
left;right
# Chunk 9
cat("L'intervalle de confiance a 95% sera compris entre", left , "et" , right, ". On peut estimer que la mean de la taille des tomatos de la population se trouve dans cette intervalle ave cun risque d'erreur de 5%. ")
# Chunk 10
error_99 = qt(0.995, df=n-1)*sd_tomatos/sqrt(n_tomatos)
left_99_tomatos = mean_tomatos - error_99
right_99_tomatos = mean_tomatos + error_99
left_99_tomatos;right_99_tomatos
# Chunk 11
cat("L'intervalle de confiance a 95% sera compris entre", left_99_tomatos , "et" , right_99_tomatos , ". On peut estimer que la mean de la taille des tomatos de la population se trouve dans cette intervalle ave cun risque d'erreur de 1%.")
# Chunk 12
frequence_red_apples = 0.4 # fréquence de pommes rouges dans l'échantillon
n = 125 # taille de l'échantillon
error_red_apple = qnorm(0.975)*sqrt(frequence_red_apples*(1-frequence_red_apples)/n)
left_apples = frequence_red_apples - error_red_apple
right_apples = frequence_red_apples + error_red_apple
left_apples;right_apples
cat("L'intervalle ayant 95% de chance d'obtenir la vrai proportion p de la popualtion est entre" , left_apples, "et",  right_apples)
# Chunk 1: Chemins_fichiers
# On peut nommer les Chunk
library(here)
# creer un dossier ou stocker les figures si besoin
dir.create(here("figure_tp2") , recursive = TRUE)
# Chunk 2: Setup de notre Rmd
knitr::opts_chunk$set(echo = TRUE , warning = FALSE , message = FALSE ,
fig.width = 6, fig.height = 4 , dpi =150,
fig.path = "figure_tp2/"
)
# Ici, nous allons etablir les options pour l'affichage du code, message d'erreur et le format des images)
# Chunk 3: Regression_lineaire
genomes = read.table(params$fichier_bacteries , sep = params$separateur_bacterias , header = TRUE)
names(genomes)
with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
# L'unité de mesure est de l'ordre des milions de paires de bases.
# On peut calculer la relation entre ces 2 variables mais aussi le coefficient de Pearson.
cov_xy = with(genomes, cov(Genome_size , ORF_number))
r_xy = with(genomes, cor(Genome_size , ORF_number))
cat(sprintf("Covariance = %.0f ; r (Pearson) = %.2f\n", cov_xy, r_xy))
#On observe une valeur de covariance de 4005883 et un coefficient de correlation de Pearson de 0.96. On a une correlation positive.
ligneregression= lm(ORF_number~Genome_size, data = genomes) # Nous n'avons utilisé pas attach donc faut lui preciser sur quoi on travaille.
# Ajout de la droite de regréssion
with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
abline(ligneregression , col="red", lwd=2)
summary(ligneregression)
# Chunk 4: Calcul_probabilite
data_sequoia = read.table(params$fichier_sequoia , sep = params$separateur_sequoia , header = TRUE)
names(data_sequoia)
hist(data_sequoia$taille_arbre,
main="Histogramme representant la taille des arbres Sequoia",
ylab='Frequence',
col='salmon' )
mean_taille_sequoia = mean(data_sequoia$taille_arbre)
ecart_type_sequoia = sd(data_sequoia$taille_arbre)
cat("La taille moyenne est de" , mean_taille_sequoia , " et l'écart-type est" , ecart_type_sequoia
)
histogramme_taille_arbre = function() { hist(data_sequoia$taille_arbre , main="Histogramme representant la taille des arbres Sequoia" , ylab='Frequence' , xlab='Taille des arbres' ) }
histogramme_taille_arbre()
outfile_seq = here("figure_tp2" , "histogramme_taille_arbre.jpg")
jpeg(outfile_seq)
histogramme_taille_arbre()
dev.off()
if ( file.exists(outfile_seq)) {
cat("Le fichier a bien ete genérée.
" , outfile_seq )
} # Utilisation de if pour envoyer un output qui confirme l'existence de notre fichier.
## Quel est la probabilité qu'un arbre mesure 80 m ?
proba_arbre_80m = length(which(data_sequoia$taille_arbre==80))/length(data_sequoia$taille_arbre)
cat("La probabilité qu'un arbre mesure 80m est de", proba_arbre_80m)
## Quel est la probabilité qu'un arbre mesure 100 m ?
proba_arbre_100m = length(data_sequoia$taille_arbre[data_sequoia$taille_arbre>100])/length(data_sequoia$taille_arbre)
cat("La probabilité qu'un arbre mesure 100m est de", proba_arbre_100m)
## Calcul basés sur une loi centrée réduite N(0,1)
dnorm(0,0,1) # On a ici x=0, mean=0 et sd=1 respectivement. Ici , x est une variable aleatoire, mean correspond à la mean de la population et sd c'est l'ecart type de la popualtion.
hist(rnorm(100,0,1), col='red')
# En augmentant n, on va tendre vers une figure de plus en plus symetrique centrée normale.
pnorm(0,0,1)
hist(rnorm(10000,0,1))
# On va calculer la mean et écart type des tailles des séquoia pour calculer la probabilité qu'u arbre mesure 80m.
calcul_arbre80m = round(dnorm(80,mean_taille_sequoia , ecart_type_sequoia ) , 3)
calcul_arbre80m
calcul_arbre100m = round(pnorm(100,mean_taille_sequoia, ecart_type_sequoia, lower.tail = FALSE),3)
calcul_arbre100m
# Chunk 5
cat("La probabilité qu'un arbre fasse 80m selon la loi normal est de",calcul_arbre80m)
cat("Le calcul des probabilités qu'un arbre mesure 100m ou plus est de", calcul_arbre100m,". Cette valeur est legerement differente que le calcul direct par nombre d'arbres de 100m divisé par le total.", proba_arbre_100m, "vs", calcul_arbre100m)
# Chunk 6: Loi_Binomiale
n=100
p=0.8
proba_80_graines_germent = dbinom(80,n,prob=p)
proba_au_max80_graines_germent = pbinom(80,n,prob=p)
proba_plus_de_80_graines_germent = pbinom(80,n,prob=p , lower.tail=F)
cat("La probabilité que 80 graines germent est de" ,proba_80_graines_germent)
# Chunk 7
cat("La probabilité que au maximum 80 graines germent est de",proba_au_max80_graines_germent)
cat("La probabilité que plus de 80 graines germent est de",proba_plus_de_80_graines_germent)
# Pour trouver combien de graines en mean devraient germer, on multiplie n par p (np)
mean_graines_germes = n*p
cat("D'apres notre n et p, on devrait s'attendre en mean a" , mean_graines_germes)
k = seq(0,100,1)
## Afficher figure
figure_loi_binomiale = function() { plot(dbinom(k,100,prob=0.8), xlab="k" , ylab="Prob(X=k)" , col="red", main="Loi Binomiale B(100,0.8)") }
figure_loi_binomiale()
outfile = here("figure_tp2" , "figure_loi_binomiale.jpg")
jpeg(outfile)
figure_loi_binomiale()
dev.off()
if ( file.exists(outfile)) {
cat("Le fichier a bien ete genérée. " , outfile) }
# Utilisation de if pour envoyer un output qui confirme l'existence de notre fichier.
# Chunk 8: Intervalle_de_confiance
data_tomatos = read.table(params$fichier_tomatos , sep = params$separateur_tomatos , header=T)
names(data_tomatos)
mean_tomatos = mean(data_tomatos$poids_tomate)
sd_tomatos = sd(data_tomatos$poids_tomate)
n_tomatos = length(data_tomatos$poids_tomate)
# Intervalle de confiance de la mean théorique µ de la popualtion, à partir de la mean m calculé sur un échantillon.
# Intervalle de confiance a 95%
error = qt(0.975, df=n-1)*sd_tomatos/sqrt(n_tomatos)
left = mean_tomatos - error
right = mean_tomatos + error
left;right
# Chunk 9
cat("L'intervalle de confiance a 95% sera compris entre", left , "et" , right, ". On peut estimer que la mean de la taille des tomatos de la population se trouve dans cette intervalle ave cun risque d'erreur de 5%. ")
# Chunk 10
error_99 = qt(0.995, df=n-1)*sd_tomatos/sqrt(n_tomatos)
left_99_tomatos = mean_tomatos - error_99
right_99_tomatos = mean_tomatos + error_99
left_99_tomatos;right_99_tomatos
# Chunk 11
cat("L'intervalle de confiance a 95% sera compris entre", left_99_tomatos , "et" , right_99_tomatos , ". On peut estimer que la mean de la taille des tomatos de la population se trouve dans cette intervalle ave cun risque d'erreur de 1%.")
# Chunk 12
frequence_red_apples = 0.4 # fréquence de pommes rouges dans l'échantillon
n = 125 # taille de l'échantillon
error_red_apple = qnorm(0.975)*sqrt(frequence_red_apples*(1-frequence_red_apples)/n)
left_apples = frequence_red_apples - error_red_apple
right_apples = frequence_red_apples + error_red_apple
left_apples;right_apples
cat("L'intervalle ayant 95% de chance d'obtenir la vrai proportion p de la popualtion est entre" , left_apples, "et",  right_apples)
with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
relation_Genome_size_nb_ORF = with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
abline(ligneregression , col="red", lwd=2)
with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
cov_xy = with(genomes, cov(Genome_size , ORF_number))
r_xy = with(genomes, cor(Genome_size , ORF_number))
cat(sprintf("Covariance = %.0f ; r (Pearson) = %.2f\n", cov_xy, r_xy))
ligneregression= lm(ORF_number~Genome_size, data = genomes) # Nous n'avons utilisé pas attach donc faut lui preciser sur quoi on travaille.
summary(ligneregression)
relation_Genome_size_nb_ORF = function() { with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " )) }
relation_Genome_size_nb_ORF()
outfile_bacterias = here("figure_tp2" , "relation_Genome_size_nb_ORF.jpg")
jpeg(outfile_bacterias)
relation_Genome_size_nb_ORF()
dev.off()
# Chunk 1: Chemins_fichiers
# On peut nommer les Chunk
library(here)
# creer un dossier ou stocker les figures si besoin
dir.create(here("figure_tp2") , recursive = TRUE)
# Chunk 2: Setup de notre Rmd
knitr::opts_chunk$set(echo = TRUE , warning = FALSE , message = FALSE ,
fig.width = 6, fig.height = 4 , dpi =150,
fig.path = "figure_tp2/"
)
# Ici, nous allons etablir les options pour l'affichage du code, message d'erreur et le format des images)
# Chunk 3: Regression_lineaire
genomes = read.table(params$fichier_bacteries , sep = params$separateur_bacterias , header = TRUE)
names(genomes)
with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
# L'unité de mesure est de l'ordre des milions de paires de bases.
# On peut calculer la relation entre ces 2 variables mais aussi le coefficient de Pearson.
cov_xy = with(genomes, cov(Genome_size , ORF_number))
r_xy = with(genomes, cor(Genome_size , ORF_number))
cat(sprintf("Covariance = %.0f ; r (Pearson) = %.2f\n", cov_xy, r_xy))
#On observe une valeur de covariance de 4005883 et un coefficient de correlation de Pearson de 0.96. On a une correlation positive.
ligneregression= lm(ORF_number~Genome_size, data = genomes) # Nous n'avons utilisé pas attach donc faut lui preciser sur quoi on travaille.
# Ajout de la droite de regréssion
summary(ligneregression)
relation_Genome_size_nb_ORF = function() { with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " )) }
relation_Genome_size_nb_ORF()
outfile_bacterias = here("figure_tp2" , "relation_Genome_size_nb_ORF.jpg")
jpeg(outfile_bacterias)
relation_Genome_size_nb_ORF()
dev.off()
# Chunk 4: Calcul_probabilite
data_sequoia = read.table(params$fichier_sequoia , sep = params$separateur_sequoia , header = TRUE)
names(data_sequoia)
hist(data_sequoia$taille_arbre,
main="Histogramme representant la taille des arbres Sequoia",
ylab='Frequence',
col='salmon' )
mean_taille_sequoia = mean(data_sequoia$taille_arbre)
ecart_type_sequoia = sd(data_sequoia$taille_arbre)
cat("La taille moyenne est de" , mean_taille_sequoia , " et l'écart-type est" , ecart_type_sequoia
)
histogramme_taille_arbre = function() { hist(data_sequoia$taille_arbre , main="Histogramme representant la taille des arbres Sequoia" , ylab='Frequence' , xlab='Taille des arbres' ) }
histogramme_taille_arbre()
outfile_seq = here("figure_tp2" , "histogramme_taille_arbre.jpg")
jpeg(outfile_seq)
histogramme_taille_arbre()
dev.off()
if ( file.exists(outfile_seq)) {
cat("Le fichier a bien ete genérée.
" , outfile_seq )
} # Utilisation de if pour envoyer un output qui confirme l'existence de notre fichier.
## Quel est la probabilité qu'un arbre mesure 80 m ?
proba_arbre_80m = length(which(data_sequoia$taille_arbre==80))/length(data_sequoia$taille_arbre)
cat("La probabilité qu'un arbre mesure 80m est de", proba_arbre_80m)
## Quel est la probabilité qu'un arbre mesure 100 m ?
proba_arbre_100m = length(data_sequoia$taille_arbre[data_sequoia$taille_arbre>100])/length(data_sequoia$taille_arbre)
cat("La probabilité qu'un arbre mesure 100m est de", proba_arbre_100m)
## Calcul basés sur une loi centrée réduite N(0,1)
dnorm(0,0,1) # On a ici x=0, mean=0 et sd=1 respectivement. Ici , x est une variable aleatoire, mean correspond à la mean de la population et sd c'est l'ecart type de la popualtion.
hist(rnorm(100,0,1), col='red')
# En augmentant n, on va tendre vers une figure de plus en plus symetrique centrée normale.
pnorm(0,0,1)
hist(rnorm(10000,0,1))
# On va calculer la mean et écart type des tailles des séquoia pour calculer la probabilité qu'u arbre mesure 80m.
calcul_arbre80m = round(dnorm(80,mean_taille_sequoia , ecart_type_sequoia ) , 3)
calcul_arbre80m
calcul_arbre100m = round(pnorm(100,mean_taille_sequoia, ecart_type_sequoia, lower.tail = FALSE),3)
calcul_arbre100m
# Chunk 5
cat("La probabilité qu'un arbre fasse 80m selon la loi normal est de",calcul_arbre80m)
cat("Le calcul des probabilités qu'un arbre mesure 100m ou plus est de", calcul_arbre100m,". Cette valeur est legerement differente que le calcul direct par nombre d'arbres de 100m divisé par le total.", proba_arbre_100m, "vs", calcul_arbre100m)
# Chunk 6: Loi_Binomiale
n=100
p=0.8
proba_80_graines_germent = dbinom(80,n,prob=p)
proba_au_max80_graines_germent = pbinom(80,n,prob=p)
proba_plus_de_80_graines_germent = pbinom(80,n,prob=p , lower.tail=F)
cat("La probabilité que 80 graines germent est de" ,proba_80_graines_germent)
# Chunk 7
cat("La probabilité que au maximum 80 graines germent est de",proba_au_max80_graines_germent)
cat("La probabilité que plus de 80 graines germent est de",proba_plus_de_80_graines_germent)
# Pour trouver combien de graines en mean devraient germer, on multiplie n par p (np)
mean_graines_germes = n*p
cat("D'apres notre n et p, on devrait s'attendre en mean a" , mean_graines_germes)
k = seq(0,100,1)
## Afficher figure
figure_loi_binomiale = function() { plot(dbinom(k,100,prob=0.8), xlab="k" , ylab="Prob(X=k)" , col="red", main="Loi Binomiale B(100,0.8)") }
figure_loi_binomiale()
outfile = here("figure_tp2" , "figure_loi_binomiale.jpg")
jpeg(outfile)
figure_loi_binomiale()
dev.off()
if ( file.exists(outfile)) {
cat("Le fichier a bien ete genérée. " , outfile) }
# Utilisation de if pour envoyer un output qui confirme l'existence de notre fichier.
# Chunk 8: Intervalle_de_confiance
data_tomatos = read.table(params$fichier_tomatos , sep = params$separateur_tomatos , header=T)
names(data_tomatos)
mean_tomatos = mean(data_tomatos$poids_tomate)
sd_tomatos = sd(data_tomatos$poids_tomate)
n_tomatos = length(data_tomatos$poids_tomate)
# Intervalle de confiance de la mean théorique µ de la popualtion, à partir de la mean m calculé sur un échantillon.
# Intervalle de confiance a 95%
error = qt(0.975, df=n-1)*sd_tomatos/sqrt(n_tomatos)
left = mean_tomatos - error
right = mean_tomatos + error
left;right
# Chunk 9
cat("L'intervalle de confiance a 95% sera compris entre", left , "et" , right, ". On peut estimer que la mean de la taille des tomatos de la population se trouve dans cette intervalle ave cun risque d'erreur de 5%. ")
# Chunk 10
error_99 = qt(0.995, df=n-1)*sd_tomatos/sqrt(n_tomatos)
left_99_tomatos = mean_tomatos - error_99
right_99_tomatos = mean_tomatos + error_99
left_99_tomatos;right_99_tomatos
# Chunk 11
cat("L'intervalle de confiance a 95% sera compris entre", left_99_tomatos , "et" , right_99_tomatos , ". On peut estimer que la mean de la taille des tomatos de la population se trouve dans cette intervalle ave cun risque d'erreur de 1%.")
# Chunk 12
frequence_red_apples = 0.4 # fréquence de pommes rouges dans l'échantillon
n = 125 # taille de l'échantillon
error_red_apple = qnorm(0.975)*sqrt(frequence_red_apples*(1-frequence_red_apples)/n)
left_apples = frequence_red_apples - error_red_apple
right_apples = frequence_red_apples + error_red_apple
left_apples;right_apples
cat("L'intervalle ayant 95% de chance d'obtenir la vrai proportion p de la popualtion est entre" , left_apples, "et",  right_apples)
abline(ligneregression , col="red", lwd=2) }
relation_Genome_size_nb_ORF = function() { with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " )
relation_Genome_size_nb_ORF()
outfile_bacterias = here("figure_tp2" , "relation_Genome_size_nb_ORF.jpg")
relation_Genome_size_nb_ORF = with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ))
abline(ligneregression , col="red", lwd=2)
summary(ligneregression)
relation_Genome_size_nb_ORF = function() { with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " )
relation_Genome_size_nb_ORF()
relation_Genome_size_nb_ORF = function() { with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ) abline(ligneregression , col="red", lwd=2) }
relation_Genome_size_nb_ORF = function() { with(genomes , plot(Genome_size , ORF_number , pch=16 , ylab="Nombre d'ORF" , xlab = "Taille du génome (pb)" , main="Relation de la taille des genomes avec le nombre d'ORF. " ) , abline(ligneregression , col="red", lwd=2) }
with(genomes , {plot(Genome_size , ORF_number , pch=16 ,
ylab="Nombre d'ORF" ,
xlab = "Taille du génome (pb)" ,
main="Relation de la taille des genomes avec le nombre d'ORF. " )
abline(ligneregression , col="red", lwd=2)
})
relation_Genome_size_nb_ORF = function() {
with(genomes , {plot(Genome_size , ORF_number , pch=16 ,
ylab="Nombre d'ORF" ,
xlab = "Taille du génome (pb)" ,
main="Relation de la taille des genomes avec le nombre d'ORF. " )
abline(ligneregression , col="red", lwd=2)
})
}
relation_Genome_size_nb_ORF()
outfile_bacterias = here("figure_tp2" , "relation_Genome_size_nb_ORF.jpg")
jpeg(outfile_bacterias)
relation_Genome_size_nb_ORF()
dev.off()
